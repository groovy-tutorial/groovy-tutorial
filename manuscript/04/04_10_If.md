# The `if` Statement {#chif}

I> Like a Choose Your Own Adventure, the `if` statement lets you select what you want to have happen.

Few programs consist of a set of statements read one after another from top-to-bottom. At various points we need the code to evaluate one set of statements rather than another - depending on the current context in which the program is running. The `if` statement is key to directing which route to take.

As an example, let's say we have some code that displays the result of a division. It's very important that we don't try to divide a number by 0 as this causes an error. In the code below we use the `if` statement to check if the denominator is `0` before we perform the division:

{title="A quick if",lang=Java}
	def numerator = 0
	def denominator = 0

	// ... various statements

	if (denominator != 0) {
	    println numerator / denominator
	}


`if` evaluates the conditional expression between the parentheses - `(..)` - and will only process the statement block if the conditional result is `true`.

## `if` - `else`

An `else` section can be provided where you want to process statements when the conditional result is `false`.

{title="`if` - `else`",lang=Java}
	def numerator = 0
	def denominator = 0

	// ... various statements

	if (denominator != 0) {
	    println numerator / denominator
	} else {
	    println 'I refuse to divide by zero'
	}


## `if` - `else if` - `else`

`if` and `else` let you deal with situations where you have two possible outcomes but sometimes you might have a few conditions that you want to check for:

{title="`if` - `else if` - `else`",lang=Java}
	def game = 'tennis'

	if (game == 'chess') {
	    println 'I like to play chess'
	} else {
	    if (game == 'tennis') {
	       println 'I can play tennis if you want'
	    } else {
	        println "Sorry, I don't know how to play $game"
	    }
	}


The code above places another `if` check within the `else` block and checks if the player is asking for a different game ("tennis"). This looks (sort of) clean but start to picture a larger set of checks and the code gets confusing. Instead of nesting the second `if` within the `else` block, Groovy lets you use `else if`:


	def game = 'tennis'

	if (game == 'chess') {
	    println 'I like to play chess'
	} else if (game == 'tennis') {
	    println 'I can play tennis if you want - just let me warm up'
	} else if (game == 'golf') {
	    println 'I can play golf if you want but I get very angry'
	} else {
	    println "Sorry, I don't know how to play $game"
	}


The code above tidies up the nesting by allowing the second `if` to be part of the `else` block. Essentially you can provide a long series of checks in a single `if-else if` set and Groovy will evaluate each until one resolves to true. You can optionally provide an `else` block at the end to ensure that can all other outcomes (defined or otherwise) be dealt with.

I> When your `if-else` chain gets a little long, look to [`switch`](#chswitch)

It's important to note that once an `if` evaluates to `true`, no other `if` expressions are evaluated. It's a case of the first positive match wins. In the code below, the conditional `(game=='chess' || game == 'tennis')` is redundant because an earlier condition would have returned `true` (`(game == 'chess')`)


	if (game == 'chess') {
	    println 'I like to play chess'
	} else if (game == 'tennis') {
	    println 'I can play tennis if you want'
	} else if (game=='chess' || game == 'tennis') {
	    println 'Can you really play both of these at once?'
	} else {
	    println "Sorry, I don't know how to play $game"
	}


That last point is also important as Groovy will also not evaluate any expressions used in further `if` expressions. In the example below, `--i` is never evaluated as the first `if` expression resolves to true:


	def i = 10

	if (++i > 10) {
		//do something
	} else if (--i < 10) {
		//do something
	}

	assert i == 11


