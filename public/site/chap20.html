<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17. Regular Expressions</title>
<link href="stylesheet.css" type="text/css" rel="stylesheet" />
</head>
<body>
<div id="leanpub-toc">
<h2></h2>
<ol class="toc has-parts">
<ul class='toc has-parts'>
  <li>
    <ul>
      <li>
        <a href='chap00.html#leanpub-auto-introduction'>Introduction</a>
      </li>
      <li>
        <a href='chap01.html#leanpub-auto-legal-notices'>Legal Notices</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap02.html#leanpub-auto-getting-started'><span class="section-number">I </span>Getting started</a>
    <ul>
      <li>
        <a href='chap03.html#leanpub-auto-installing-groovy'><span class="section-number">1. </span>Installing Groovy</a>
      </li>
      <li>
        <a href='chap04.html#leanpub-auto-your-first-lines-of-groovy'><span class="section-number">2. </span>Your first lines of Groovy</a>
      </li>
      <li>
        <a href='chap05.html#leanpub-auto-comments'><span class="section-number">3. </span>Comments</a>
      </li>
      <li>
        <a href='chap06.html#leanpub-auto-statements'><span class="section-number">4. </span>Statements</a>
      </li>
      <li>
        <a href='chap07.html#leanpub-auto-the-assert-statement'><span class="section-number">5. </span>The <code>assert</code> statement</a>
      </li>
      <li>
        <a href='chap08.html#leanpub-auto-reserved-words'><span class="section-number">6. </span>Reserved Words</a>
      </li>
      <li>
        <a href='chap09.html#leanpub-auto-packages'><span class="section-number">7. </span>Packages</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap10.html#leanpub-auto-variables'><span class="section-number">II </span>Variables</a>
    <ul>
      <li>
        <a href='chap11.html#leanpub-auto-declaring-variables'><span class="section-number">8. </span>Declaring Variables</a>
      </li>
      <li>
        <a href='chap12.html#leanpub-auto-data-types'><span class="section-number">9. </span>Data Types</a>
      </li>
      <li>
        <a href='chap13.html#leanpub-auto-objects'><span class="section-number">10. </span>Objects</a>
      </li>
      <li>
        <a href='chap14.html#leanpub-auto-booleans'><span class="section-number">11. </span>Booleans</a>
      </li>
      <li>
        <a href='chap15.html#leanpub-auto-numbers'><span class="section-number">12. </span>Numbers</a>
      </li>
      <li>
        <a href='chap16.html#leanpub-auto-strings'><span class="section-number">13. </span>Strings</a>
      </li>
      <li>
        <a href='chap17.html#leanpub-auto-collections'><span class="section-number">14. </span>Collections</a>
      </li>
      <li>
        <a href='chap18.html#leanpub-auto-arrays'><span class="section-number">15. </span>Arrays</a>
      </li>
      <li>
        <a href='chap19.html#leanpub-auto-ranges'><span class="section-number">16. </span>Ranges</a>
      </li>
      <li>
        <a href='chap20.html#leanpub-auto-regular-expressions'><span class="section-number">17. </span>Regular Expressions</a>
      </li>
      <li>
        <a href='chap21.html#leanpub-auto-data-types-1'><span class="section-number">18. </span>Data types</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap22.html#leanpub-auto-operators'><span class="section-number">III </span>Operators</a>
    <ul>
      <li>
        <a href='chap23.html#leanpub-auto-operators-1'><span class="section-number">19. </span>Operators</a>
      </li>
      <li>
        <a href='chap24.html#leanpub-auto-numeric-operators'><span class="section-number">20. </span>Numeric Operators</a>
      </li>
      <li>
        <a href='chap25.html#leanpub-auto-simple-assignment-operator'><span class="section-number">21. </span>Simple Assignment Operator</a>
      </li>
      <li>
        <a href='chap26.html#leanpub-auto-the-complement-operator'><span class="section-number">22. </span>The Complement Operator</a>
      </li>
      <li>
        <a href='chap27.html#leanpub-auto-equality-operators'><span class="section-number">23. </span>Equality Operators</a>
      </li>
      <li>
        <a href='chap28.html#leanpub-auto-arithmetic-operators'><span class="section-number">24. </span>Arithmetic operators</a>
      </li>
      <li>
        <a href='chap29.html#leanpub-auto-relational-operators'><span class="section-number">25. </span>Relational Operators</a>
      </li>
      <li>
        <a href='chap30.html#leanpub-auto-increment-and-decrement-operators'><span class="section-number">26. </span>Increment and Decrement Operators</a>
      </li>
      <li>
        <a href='chap31.html#leanpub-auto-conditional-operators'><span class="section-number">27. </span>Conditional Operators</a>
      </li>
      <li>
        <a href='chap32.html#leanpub-auto-bitwise-operators'><span class="section-number">28. </span>Bitwise Operators</a>
      </li>
      <li>
        <a href='chap33.html#leanpub-auto-compound-assignment-operators'><span class="section-number">29. </span>Compound Assignment Operators</a>
      </li>
      <li>
        <a href='chap34.html#leanpub-auto-string-operators-1'><span class="section-number">30. </span>String Operators</a>
      </li>
      <li>
        <a href='chap35.html#leanpub-auto-regular-expression-operators-1'><span class="section-number">31. </span>Regular Expression Operators</a>
      </li>
      <li>
        <a href='chap36.html#leanpub-auto-collection-operators-1'><span class="section-number">32. </span>Collection operators</a>
      </li>
      <li>
        <a href='chap37.html#leanpub-auto-object-operators-1'><span class="section-number">33. </span>Object Operators</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap38.html#leanpub-auto-control-flow-statements'><span class="section-number">IV </span>Control Flow Statements</a>
    <ul>
      <li>
        <a href='chap39.html#leanpub-auto-introduction-1'><span class="section-number">34. </span>Introduction</a>
      </li>
      <li>
        <a href='chap40.html#leanpub-auto-blocks'><span class="section-number">35. </span>Blocks</a>
      </li>
      <li>
        <a href='chap41.html#leanpub-auto-the-if-statement'><span class="section-number">36. </span>The <code>if</code> Statement</a>
      </li>
      <li>
        <a href='chap42.html#leanpub-auto-the-switch-statement'><span class="section-number">37. </span>The <code>switch</code> Statement</a>
      </li>
      <li>
        <a href='chap43.html#leanpub-auto-the-for-loop'><span class="section-number">38. </span>The <code>for</code> Loop</a>
      </li>
      <li>
        <a href='chap44.html#leanpub-auto-the-while-loop'><span class="section-number">39. </span>The <code>while</code> loop</a>
      </li>
      <li>
        <a href='chap45.html#leanpub-auto-branching-statements'><span class="section-number">40. </span>Branching statements</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap46.html#leanpub-auto-exceptions'><span class="section-number">V </span>Exceptions</a>
    <ul>
      <li>
        <a href='chap47.html#leanpub-auto-the-throwable-family'><span class="section-number">41. </span>The Throwable Family</a>
      </li>
      <li>
        <a href='chap48.html#leanpub-auto-common-exceptions'><span class="section-number">42. </span>Common Exceptions</a>
      </li>
      <li>
        <a href='chap49.html#leanpub-auto-anatomy-of-an-exception'><span class="section-number">43. </span>Anatomy of an Exception</a>
      </li>
      <li>
        <a href='chap50.html#leanpub-auto-try-catch-finally'><span class="section-number">44. </span>Try-Catch-Finally</a>
      </li>
      <li>
        <a href='chap51.html#leanpub-auto-how-much-should-we-try'><span class="section-number">45. </span>How Much Should We try?</a>
      </li>
      <li>
        <a href='chap52.html#leanpub-auto-causing-an-exception'><span class="section-number">46. </span>Causing an Exception</a>
      </li>
      <li>
        <a href='chap53.html#leanpub-auto-catching-errors'><span class="section-number">47. </span>Catching Errors</a>
      </li>
      <li>
        <a href='chap54.html#leanpub-auto-methods-and-exceptions'><span class="section-number">48. </span>Methods and Exceptions</a>
      </li>
    </ul>
  </li>
  <li>
    <a href='chap55.html#leanpub-auto-methods'><span class="section-number">VI </span>Methods</a>
    <ul>
      <li>
        <a href='chap56.html#leanpub-auto-the-basics'><span class="section-number">49. </span>The Basics</a>
      </li>
      <li>
        <a href='chap57.html#leanpub-auto-parameters'><span class="section-number">50. </span>Parameters</a>
      </li>
      <li>
        <a href='chap58.html#leanpub-auto-default-values-for-parameters'><span class="section-number">51. </span>Default Values for Parameters</a>
      </li>
      <li>
        <a href='chap59.html#leanpub-auto-named-arguments'><span class="section-number">52. </span>Named Arguments</a>
      </li>
      <li>
        <a href='chap60.html#leanpub-auto-variable-arguments-varargs'><span class="section-number">53. </span>Variable Arguments (Varargs)</a>
      </li>
      <li>
        <a href='chap61.html#leanpub-auto-return-value'><span class="section-number">54. </span>Return value</a>
      </li>
      <li>
        <a href='chap62.html#leanpub-auto-throwing-an-exception'><span class="section-number">55. </span>Throwing an exception</a>
      </li>
      <li>
        <a href='chap63.html#leanpub-auto-documenting-a-method'><span class="section-number">56. </span>Documenting a method</a>
      </li>
      <li>
        <a href='chap64.html#leanpub-auto-techniques'><span class="section-number">57. </span>Techniques</a>
      </li>
      <li>
        <a href='chap65.html#leanpub-auto-colophon'>Colophon</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main">
<h2 id="leanpub-auto-regular-expressions"><span class="section-number">17. </span>Regular Expressions</h2>

<table class="information sidebarish">
  <tbody>
    <tr><td class="sidebar-icon">
      <img class="sidebar-image" src="images/leanpub_info-circle.png" alt="information" width="50px" /></td>
    <td>
      <p>Regular expressions give us a powerful (and confusing) way of sifting through text.</p>

    </td>
  </tr>
  </tbody>
</table><p>Regular expressions (RegEx’s) get entire books devoted to them and you’ll find some developers are RegEx ninjas and others (like myself) are RegEx numpties. This chapter will introduce the basics but the <a href="http://docs.oracle.com/javase/tutorial/essential/regex/">Java Tutorial’s Regular Expression trail</a> is a useful reference as is <a href="https://en.wikipedia.org/wiki/Regular_expression">Wikipedia</a> for those seeking RegEx glory. There are also a number of online tools such as <a href="http://www.regexr.com">RegExr</a> that come in very handy when trying to debug that elusive RegEx pattern.</p>

<p>To define the regular expression pattern we use the <code>~/ /</code> syntax:</p>

<div class="code-block">
  <p class="codeblock-title">Declaring a regex</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="err">\</code><code class="n">n</code><code class="o">/</code>
</pre></div>

  <hr /></div>

<p>Once stored as a variable, this regular expression can be used in a variety of ways. The example below sets up three string variables and tests them against the <code>regex</code> pattern by using the <code>matches</code> method - which returns <code>true</code> if the string matches the pattern: </p>

<div class="code-block">
  <p class="codeblock-title">Matching against a regex</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="n">https</code><code class="o">?:</code><code class="err">\</code><code class="o">/</code><code class="err">\</code><code class="o">/</code><code class="p">.</code><code class="err">*/</code>

<code class="n">def</code> <code class="n">httpUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">http</code><code class="o">:</code><code class="c1">//www.example.com/'</code>
<code class="n">def</code> <code class="n">httpsUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">https</code><code class="o">:</code><code class="c1">//secure.example.com/'</code>
<code class="n">def</code> <code class="n">ftpUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">ftp</code><code class="o">:</code><code class="c1">//ftp.example.com/'</code>

<code class="n">assert</code> <code class="n">httpUrl</code><code class="p">.</code><code class="n">matches</code><code class="p">(</code><code class="n">regex</code><code class="p">)</code>
<code class="n">assert</code> <code class="n">httpsUrl</code><code class="p">.</code><code class="n">matches</code><code class="p">(</code><code class="n">regex</code><code class="p">)</code>
<code class="n">assert</code> <code class="o">!</code> <code class="n">ftpUrl</code><code class="p">.</code><code class="n">matches</code><code class="p">(</code><code class="n">regex</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<p>In the code above, <code>~/https?:\/\/.*/</code> is the regular expression pattern that’s essentially looking for any string starting with <code>http</code> or <code>https</code>. The <code>s?</code> will match 0 or 1 occurrence of <code>s</code> in the pattern. You’ll notice the odd-looking <code>\/\/</code> - I need to escape the forward slashes in <code>http://</code> so that Groovy doesn’t confuse them with the slashes used to define the regular expression pattern (<code>~/../</code>).</p>

<p>We’ll also look at the special operators for regular expressions in the next tutorial: Operators.</p>

<p>Underpinning Groovy’s regular expression functionality is the Java class <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html"><code>java.util.regex.Pattern</code></a>. Groovy handles the compiling of the pattern and this helps you focus on the struggle of getting the regular expression correct :)</p>

<h3 id="leanpub-auto-regular-expression-syntax">Regular Expression Syntax</h3>

<p>Regular expressions use a number of syntactic elements to define a pattern of text. We’ll take a brief look at them here.</p>

<h4 id="leanpub-auto-characters">Characters</h4>

<p>These elements are used to match specific literal characters.</p>


<p class="table-title">Literal characters</p>

<table>
  <thead>
    <tr><th style="text-align: center">Element</th>
      <th>Matches</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="text-align: center"><code>g</code></td>
      <td>The character <code>g</code></td>
    </tr>
    <tr><td style="text-align: center"><code>\\</code></td>
      <td>The backslash character</td>
    </tr>
    <tr><td style="text-align: center"><code>\t</code></td>
      <td>Tab character</td>
    </tr>
    <tr><td style="text-align: center"><code>\n</code></td>
      <td>Newline character</td>
    </tr>
    <tr><td style="text-align: center"><code>\f</code></td>
      <td>Formfeed character</td>
    </tr>
    <tr><td style="text-align: center"><code>\r</code></td>
      <td>Carriage-return character</td>
    </tr>
  </tbody>
</table><p>In the example below I take a section of a poem and use the <code>split</code> method to get a list whose elements contain a single line from the poem.</p>

<div class="code-block">
  <p class="codeblock-title">Splitting a poem</p>

  <hr /><div class="highlight"><pre><code class="c1">// The Ballad of the Drover by Henry Lawson</code>
<code class="n">def</code> <code class="n">poem</code> <code class="o">=</code> <code class="p">'''</code>\
 <code class="n">Across</code> <code class="n">the</code> <code class="n">stony</code> <code class="n">ridges</code><code class="p">,</code>
  <code class="n">Across</code> <code class="n">the</code> <code class="n">rolling</code> <code class="n">plain</code><code class="p">,</code>
 <code class="n">Young</code> <code class="n">Harry</code> <code class="n">Dale</code><code class="p">,</code> <code class="n">the</code> <code class="n">drover</code><code class="p">,</code>
  <code class="n">Comes</code> <code class="n">riding</code> <code class="n">home</code> <code class="n">again</code><code class="p">.</code>
 <code class="n">And</code> <code class="n">well</code> <code class="n">his</code> <code class="n">stock</code><code class="o">-</code><code class="n">horse</code> <code class="n">bears</code> <code class="n">him</code><code class="p">,</code>
  <code class="n">And</code> <code class="n">light</code> <code class="n">of</code> <code class="n">heart</code> <code class="n">is</code> <code class="n">he</code><code class="p">,</code>
 <code class="n">And</code> <code class="n">stoutly</code> <code class="n">his</code> <code class="n">old</code> <code class="n">pack</code><code class="o">-</code><code class="n">horse</code>
  <code class="n">Is</code> <code class="n">trotting</code> <code class="n">by</code> <code class="n">his</code> <code class="n">knee</code><code class="p">.'''</code>

<code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="err">\</code><code class="n">n</code><code class="o">/</code>

<code class="n">def</code> <code class="n">lines</code> <code class="o">=</code> <code class="n">regex</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="n">poem</code><code class="p">)</code>

<code class="n">def</code> <code class="n">i</code> <code class="o">=</code> <code class="mh">1</code>
<code class="k">for</code> <code class="p">(</code><code class="n">line</code> <code class="n">in</code> <code class="n">lines</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">println</code> <code class="s">"Line $i: $line"</code>
    <code class="n">i</code><code class="o">++</code>
<code class="p">}</code>
</pre></div>

  <hr /></div>

<h4 id="leanpub-auto-character-classes">Character Classes</h4>

<p>Character classes are used to define character sets and sequences.</p>


<p class="table-title">Character classes</p>

<table>
  <thead>
    <tr><th style="text-align: center">Element</th>
      <th>Matches</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="text-align: center"><code>[xyz]</code></td>
      <td><code>x</code>, <code>y</code> or <code>z</code></td>
    </tr>
    <tr><td style="text-align: center"><code>[^xyz]</code></td>
      <td>Not <code>x</code>, <code>y</code> or <code>z</code></td>
    </tr>
    <tr><td style="text-align: center"><code>[a-zA-Z]</code></td>
      <td>Range of characters (all letters)</td>
    </tr>
    <tr><td style="text-align: center"><code>[0-9]</code></td>
      <td>Range of characters (all numbers)</td>
    </tr>
    <tr><td style="text-align: center"><code>[a-zA-Z_0-9]</code></td>
      <td>Range of characters</td>
    </tr>
  </tbody>
</table><h5 id="leanpub-auto-predefined-character-classes">Predefined Character Classes</h5>

<p>The predefined character classes save you from having to define the class specifically and are handy for seeking out words and whitespace.</p>


<p class="table-title">Predefined character classes</p>

<table>
  <thead>
    <tr><th style="text-align: center">Element</th>
      <th>Matches</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="text-align: center"><code>.</code></td>
      <td>Any character</td>
    </tr>
    <tr><td style="text-align: center"><code>\d</code></td>
      <td>Digits <code>[0-9]</code></td>
    </tr>
    <tr><td style="text-align: center"><code>\D</code></td>
      <td>Non-digits</td>
    </tr>
    <tr><td style="text-align: center"><code>\s</code></td>
      <td>Whitespace</td>
    </tr>
    <tr><td style="text-align: center"><code>\S</code></td>
      <td>Not whitespace</td>
    </tr>
    <tr><td style="text-align: center"><code>\w</code></td>
      <td>Word character <code>[a-zA-Z_0-9]</code></td>
    </tr>
    <tr><td style="text-align: center"><code>\W</code></td>
      <td>Not a word character</td>
    </tr>
  </tbody>
</table><h4 id="leanpub-auto-boundaries">Boundaries</h4>

<p>Boundaries, to state the obvious, mark the edge of something - specifically a line or a word.</p>


<p class="table-title">Boundaries</p>

<table>
  <thead>
    <tr><th style="text-align: center">Element</th>
      <th>Matches</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="text-align: center"><code>^</code></td>
      <td>Start of a line</td>
    </tr>
    <tr><td style="text-align: center"><code>$</code></td>
      <td>End of a line</td>
    </tr>
    <tr><td style="text-align: center"><code>\b</code></td>
      <td>Word boundary</td>
    </tr>
    <tr><td style="text-align: center"><code>\B</code></td>
      <td>Non-word boundary</td>
    </tr>
  </tbody>
</table><h4 id="leanpub-auto-quantifiers">Quantifiers</h4>

<p>These determine how many matches are acceptable. For example <code>s?</code> matches the character <code>s</code> zero or one time - meaning that I expect that character to be an <code>s</code> or, if it’s not, move to the next part of the pattern. <code>s+</code> means  that I really want at least one <code>s</code> at that point.</p>


<p class="table-title">Quantifiers</p>

<table>
  <thead>
    <tr><th style="text-align: center">Element</th>
      <th>Matches</th>
    </tr>
  </thead>
  <tbody>
    <tr><td style="text-align: center"><code>?</code></td>
      <td>Single match</td>
    </tr>
    <tr><td style="text-align: center"><code>*</code></td>
      <td>Zero or more matches</td>
    </tr>
    <tr><td style="text-align: center"><code>+</code></td>
      <td>One or more matches</td>
    </tr>
    <tr><td style="text-align: center"><code>{n}?</code></td>
      <td>Exactly <em>n</em> matches</td>
    </tr>
    <tr><td style="text-align: center"><code>{n, }?</code></td>
      <td>At least <em>n</em> matches</td>
    </tr>
    <tr><td style="text-align: center"><code>{n,m}?</code></td>
      <td>At least <em>n</em> but not more that <em>m</em> matches</td>
    </tr>
  </tbody>
</table><h3 id="leanpub-auto-useful-methods-4">Useful Methods</h3>

<p>A number of String methods can accept a regular expression and these are my preferred approach to checking text against regular expressions. Most of them take the pattern as the first parameter.</p>

<p>We saw the <code>matches()</code> method at the beginning of the chapter:</p>

<div class="code-block">
  <p class="codeblock-title">Matching</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="n">https</code><code class="o">?:</code><code class="err">\</code><code class="o">/</code><code class="err">\</code><code class="o">/</code><code class="p">.</code><code class="err">*/</code>
<code class="n">def</code> <code class="n">httpUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">http</code><code class="o">:</code><code class="c1">//www.example.com/'</code>

<code class="n">assert</code> <code class="n">httpUrl</code><code class="p">.</code><code class="n">matches</code><code class="p">(</code><code class="n">regex</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<p>The <code>find()</code> method returns the first match against the pattern within the string. In the example below the <code>find()</code> will return the match against the port number in the URL:</p>

<div class="code-block">
  <p class="codeblock-title">Finding</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/:</code><code class="p">[</code><code class="mi">0</code><code class="o">-</code><code class="mi">9</code><code class="p">]</code><code class="o">+/</code>
<code class="n">def</code> <code class="n">httpUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">http</code><code class="o">:</code><code class="c1">//www.example.com:8080/'</code>

<code class="n">println</code> <code class="n">httpUrl</code><code class="p">.</code><code class="n">find</code><code class="p">(</code><code class="n">regex</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<p>The <code>findAll()</code> method returns a list of matches for the pattern. In the example below I am returned all words in <code>speech</code> that start with <code>like</code>:</p>

<div class="code-block">
  <p class="codeblock-title"><code>findAll</code></p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">speech</code> <code class="o">=</code> <code class="err">'''</code><code class="n">This</code> <code class="n">like</code> <code class="n">guy</code> <code class="n">like</code> <code class="n">I</code> <code class="n">know</code> <code class="n">but</code> <code class="n">like</code> <code class="n">don</code><code class="err">\'</code><code class="n">t</code> <code class="n">really</code> <code class="n">like</code> 
 <code class="n">was</code> <code class="n">like</code> <code class="n">so</code> <code class="n">mean</code> <code class="n">but</code> <code class="n">likely</code> <code class="n">to</code> <code class="n">be</code> <code class="n">nice</code> <code class="n">when</code> <code class="n">you</code> <code class="n">know</code> <code class="n">him</code> <code class="n">better</code><code class="p">.</code><code class="err">'''</code>

<code class="n">println</code> <code class="n">speech</code><code class="p">.</code><code class="n">findAll</code><code class="p">(</code><code class="o">~/</code><code class="err">\</code><code class="n">blike</code><code class="err">\</code><code class="n">w</code><code class="o">*</code><code class="err">\</code><code class="n">b</code><code class="o">/</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<blockquote>
  <p>Like, wow!</p>
</blockquote>

<p>The example below provides a very basic word counter by seeking out the <code>\b\w+\b</code> pattern and displaying the size of the list returned by <code>findAll</code>:</p>

<div class="code-block">
  <p class="codeblock-title">A word counter</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">poem</code> <code class="o">=</code> <code class="err">'''</code>\
 <code class="n">Across</code> <code class="n">the</code> <code class="n">stony</code> <code class="n">ridges</code><code class="p">,</code>
  <code class="n">Across</code> <code class="n">the</code> <code class="n">rolling</code> <code class="n">plain</code><code class="p">,</code>
 <code class="n">Young</code> <code class="n">Harry</code> <code class="n">Dale</code><code class="p">,</code> <code class="n">the</code> <code class="n">drover</code><code class="p">,</code>
  <code class="n">Comes</code> <code class="n">riding</code> <code class="n">home</code> <code class="n">again</code><code class="p">.</code><code class="err">'''</code>
  
<code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="err">\</code><code class="n">b</code><code class="err">\</code><code class="n">w</code><code class="o">+</code><code class="err">\</code><code class="n">b</code><code class="o">/</code>

<code class="n">println</code> <code class="n">poem</code><code class="p">.</code><code class="n">findAll</code><code class="p">(</code><code class="n">regex</code><code class="p">).</code><code class="n">size</code><code class="p">()</code>
</pre></div>

  <hr /></div>

<p>The <code>replaceFirst()</code> and <code>replaceAll()</code> methods seek out matches and replace them in a manner that their names implies:</p>

<div class="code-block">
  <p class="codeblock-title">Replacing</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">speech</code> <code class="o">=</code> <code class="err">'''</code><code class="n">This</code> <code class="n">like</code> <code class="n">guy</code> <code class="n">like</code> <code class="n">I</code> <code class="n">know</code> <code class="n">but</code> <code class="n">like</code> <code class="n">don</code><code class="err">\'</code><code class="n">t</code> <code class="n">really</code> <code class="n">like</code> 
 <code class="n">was</code> <code class="n">like</code> <code class="n">so</code> <code class="n">mean</code> <code class="n">but</code> <code class="n">likely</code> <code class="n">to</code> <code class="n">be</code> <code class="n">a</code> <code class="n">nice</code> <code class="n">guy</code> <code class="n">when</code> <code class="n">you</code> <code class="n">know</code> <code class="n">him</code> <code class="n">better</code><code class="p">.</code><code class="err">'''</code>

<code class="n">println</code> <code class="n">speech</code><code class="p">.</code><code class="n">replaceAll</code><code class="p">(</code><code class="o">~/</code><code class="err">\</code><code class="n">blike</code><code class="err">\</code><code class="n">b</code><code class="o">/</code><code class="p">,</code> <code class="err">'</code><code class="n">um</code><code class="err">'</code><code class="p">)</code>
<code class="n">println</code> <code class="n">speech</code><code class="p">.</code><code class="n">replaceFirst</code><code class="p">(</code><code class="o">~/</code><code class="err">\</code><code class="n">bguy</code><code class="err">\</code><code class="n">b</code><code class="o">/</code><code class="p">,</code> <code class="err">'</code><code class="n">marmoset</code><code class="err">'</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<p>The <code>splitEachLine()</code> method is very handy when handling structured files such as comma-separated files. You can see in the example below that the first parameter is the pattern that will match commas (<code>~/,/</code>) and the second parameter is a closure that will do something for each line. Within the closure,  the <code>it</code> variable is a list with each element being the delimited segment of the text with the line:</p>

<div class="code-block">
  <p class="codeblock-title">Splitting</p>

  <hr /><div class="highlight"><pre>def csv = '''\
Bill,555-1234,cats
Jane,555-7485,dogs
Indira,555-0021,birds'''

csv.splitEachLine(~/,/) {
    println "Name: <code class="cp">${</code><code class="n">it</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="cp">}</code>"
}
</pre></div>

  <hr /></div>

<h4 id="leanpub-auto-pattern-methods">Pattern Methods</h4>

<p>The <code>java.util.regex.Pattern</code> class provides a number of useful methods. I prefer to use the String methods but maybe I’m just lazy.</p>

<p>The static <code>matches</code> method is called against <code>Pattern</code> to evaluate a pattern against a piece of text. You’ll note that the first parameter is the pattern but represented as a string so you drop the <code>~/../</code> notation:</p>

<div class="code-block">
  <p class="codeblock-title">Using <code>Pattern</code></p>

  <hr /><div class="highlight"><pre><code class="o">//</code><code class="n">Note</code> <code class="n">the</code> <code class="kn">import</code>
<code class="nn">import</code> <code class="nn">java.util.regex.Pattern</code>
<code class="k">assert</code> <code class="n">Pattern</code><code class="o">.</code><code class="n">matches</code><code class="p">(</code><code class="s">'https?://.*/'</code><code class="p">,</code> <code class="s">'http://www.example.com/'</code><code class="p">)</code> <code class="o">==</code> <code class="n">true</code>
</pre></div>

  <hr /></div>

<p>The <code>matcher()</code> method is called against a regular expression pattern and is passed the text that is to be checked. A <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html"><code>Matcher</code></a> variable is returned and these give you a whole heap of regular expression functionality. In my example I just check for the match by calling <code>matches()</code>:</p>

<div class="code-block">
  <p class="codeblock-title">Using <code>Matcher</code></p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="n">https</code><code class="o">?:</code><code class="err">\</code><code class="o">/</code><code class="err">\</code><code class="o">/</code><code class="p">.</code><code class="err">*/</code>
<code class="n">def</code> <code class="n">httpUrl</code> <code class="o">=</code> <code class="err">'</code><code class="n">http</code><code class="o">:</code><code class="c1">//www.example.com/'</code>
<code class="n">def</code> <code class="n">matcher</code> <code class="o">=</code> <code class="n">regex</code><code class="p">.</code><code class="n">matcher</code><code class="p">(</code><code class="n">httpUrl</code><code class="p">)</code>
<code class="n">assert</code> <code class="n">matcher</code><code class="p">.</code><code class="n">matches</code><code class="p">()</code> <code class="o">==</code> <code class="nb">true</code>
</pre></div>

  <hr /></div>

<p>The <code>split()</code> method uses a pattern as a delimiter and returns the elements of the parameter broken up by the delimiter. In my example below I split the domain up based on the period (<code>.</code>) delimiter:</p>

<div class="code-block">
  <p class="codeblock-title">Another split`</p>

  <hr /><div class="highlight"><pre><code class="n">def</code> <code class="n">regex</code> <code class="o">=</code> <code class="o">~/</code><code class="err">\</code><code class="p">.</code><code class="o">/</code>
<code class="n">def</code> <code class="n">domain</code> <code class="o">=</code> <code class="err">'</code><code class="n">www</code><code class="p">.</code><code class="n">example</code><code class="p">.</code><code class="n">com</code><code class="err">'</code>

<code class="n">println</code> <code class="n">regex</code><code class="p">.</code><code class="n">split</code><code class="p">(</code><code class="n">domain</code><code class="p">)</code>
</pre></div>

  <hr /></div>

<p>That last example is simple but you can use some pretty funky patterns to split up a string. </p>
</div>
</body>
</html>
